<?php

/**
 * PluginfzTagTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class PluginfzTagTable extends Doctrine_Table
{

    protected $taggableModelsLoaded = false;

    /**
     * Returns an instance of this class.
     *
     * @return object PluginfzTagTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('PluginfzTag');
    }

    /**
     * Method that returns weight ordered query
     * @param integer $limit
     * @return Doctrine_Query
     * @author Grzegorz Śliwiński
     */
    public function getTagsForCloudQuery( $limit = 20)
    {
        //just to make sure, in case someone passes false, or anything
        if( !$limit or !is_numeric($limit) )
        {
            $limit = 20;
        }
        //Need to do this like that, otherwise we might get mysql error: 
        //This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
        $tags = $this->createQuery('t')->select('t.id')->where('t.weight > 0')->orderBy('t.weight DESC')->limit($limit)->execute();
        $pks = $tags->getPrimaryKeys();
        
        return $this->createQuery('t')
                ->whereIn('t.id', $pks)
                ->orderBy('RANDOM() ASC');
    }

    /**
     * This method returns sorted query, based on the passed array, that needs to consist of order & by keys
     * @param array $sortOptions
     * @return Doctrine_Query
     * @author Grzegorz Śliwiński
     */
    public function getListQuery( array $sortOptions = array() )
    {
        $query = $this->createQuery('t');

        $order = ' ASC';
        $by = 't.name';
        if(is_array($sortOptions) )
        {
            if( array_key_exists('order', $sortOptions ) && $sortOptions['order'] == 'desc' )
            {
                $order = ' DESC';
            }
            if( array_key_exists('by', $sortOptions ) && $sortOptions['by'] == 'weight' )
            {
                $by = 't.weight';
            }
        }

        return $query->orderBy($by.$order);
    }

    /**
     * Method that returns array of tags (tagName => tagName) for autocomplete.
     * @return array
     * @author Grzegorz Śliwiński
     */
    public function getTagsForAutocomplete()
    {
        return $this->createQuery('t')->select('t.name as name')
                ->execute(array(), Doctrine_Core::HYDRATE_ARRAY);
    }

    /**
     * Method executes query on tags with given ids to increase their weight
     * @param array $tagIds
     */
    public function increaseTagsWeight(Array $tagIds)
    {

        if( count( $tagIds ) > 0 )
        {
            $this->createQuery('t')->update()
                    ->set('t.weight', 't.weight + 1')
                    ->whereIn('t.id', $tagIds)->execute();
        }
    }

    /**
     * Method executes query on tags with given ids to decrease their weight
     * @param array $tagIds
     */
    public function decreaseTagsWeight(Array $tagIds)
    {
        if( count( $tagIds ) > 0 )
        {
            $this->createQuery('t')->update()
                    ->set('t.weight', 't.weight - 1')
                    ->whereIn('t.id', $tagIds)
                    ->andWhere('t.weight > 0')->execute();
        }
    }
}